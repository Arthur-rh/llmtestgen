from __future__ import annotations

from pathlib import Path
from typing import Iterable
from pydantic import BaseModel

from llmtestgen.services.test_generation.test_spec_generator import (
    TestCase,
    TestSpecification,
)


def _slugify(text: str, max_length: int = 60) -> str:
    """Convert a free-form description into a safe fragment usable in filenames."""
    import re

    text = text.lower()
    text = re.sub(r"[^a-z0-9]+", "_", text)
    text = re.sub(r"_+", "_", text).strip("_")
    if not text:
        text = "case"
    return text[:max_length]


def render_test_case_markdown(test_case: TestCase, index: int) -> str:
    """Render a single TestCase into a Markdown specification block."""
    title = test_case.id or test_case.description or f"Test {index}"
    slug = _slugify(title)
    heading = f"## Test {index:03d}: {title}"

    lines: list[str] = []
    lines.append(heading)

    # Requirement / description
    requirement = (
        f"**Requirement:** {test_case.requirement}"
        if test_case.requirement
        else f"**Description:** {test_case.description}"
    )
    lines.append(requirement)
    lines.append("")

    # Preconditions
    if test_case.preconditions:
        lines.append("### Preconditions")
        for pre in test_case.preconditions:
            lines.append(f"- {pre}")
        lines.append("")

    # Target code elements
    if test_case.target_code_elements:
        lines.append("### Target code elements")
        for elem in test_case.target_code_elements:
            lines.append(f"- `{elem}`")
        lines.append("")

    # Steps
    if test_case.steps:
        lines.append("### Steps")
        for i, step in enumerate(test_case.steps, start=1):
            lines.append(f"{i}. {step}")
        lines.append("")

    # Expected result
    if test_case.expected_result:
        lines.append("### Expected Result")
        for line in test_case.expected_result.splitlines():
            lines.append(f"- {line}")
        lines.append("")

    lines.append("---")
    lines.append("")
    return "\n".join(lines)


def render_test_spec_file_markdown(
    test_spec: TestSpecification,
    *,
    include_header: bool = True,
) -> str:
    """Render a whole TestSpecification into a Markdown document."""
    lines: list[str] = []

    if include_header:
        lines.append("# Auto-Generated Test Specification")
        lines.append("")
        lines.append(f"**Source spec:** `{test_spec.spec_source_path}`")
        if test_spec.llm_model:
            lines.append(f"**Generated by model:** `{test_spec.llm_model}`")
        lines.append("")
        lines.append("---")
        lines.append("")

    if not test_spec.test_cases:
        lines.append("_No test cases were generated._")
        return "\n".join(lines)

    for idx, tc in enumerate(test_spec.test_cases, start=1):
        lines.append(render_test_case_markdown(tc, idx))

    return "\n".join(lines).rstrip() + "\n"


def write_test_spec_file(
    test_spec: TestSpecification,
    output_path: str | Path,
    *,
    include_header: bool = True,
) -> Path:
    """Render and write the Markdown specification to disk."""
    output_path = Path(output_path)
    output_path.parent.mkdir(parents=True, exist_ok=True)

    content = render_test_spec_file_markdown(
        test_spec,
        include_header=include_header,
    )
    output_path.write_text(content, encoding="utf-8")
    return output_path
